/**
 * Configuration file generator
 */

import { stringify as stringifyYaml } from 'yaml';
import type { PresetConfig, FormatterType, GeneratedConfig, FormatterDetectionResult, SetupOptions, FormatterDetection } from '../types/index.js';
import type { Result } from '@outfitter/contracts';
import { success, failure, makeError } from '@outfitter/contracts';
import { GeneratedConfigSchema, FormatterTypeSchema } from '../schemas/index.js';
import { loadYamlPreset, mergeRawConfig, type YamlPreset } from '../utils/yaml-presets.js';

// Import config generators
import prettierConfigModule from '@outfitter/prettier-config';
import * as biomeConfigModule from '@outfitter/biome-config';
import { generate as generateRemarkConfig } from '@outfitter/remark-config';

// Type for config generator functions
type ConfigGenerator<TOptions = PresetConfig> = (options: TOptions) => unknown;

// Type guard for modules with generate function
function hasGenerateFunction(module: unknown): module is { generate: ConfigGenerator } {
  return (
    typeof module === 'object' &&
    module !== null &&
    'generate' in module &&
    typeof (module as { generate: unknown }).generate === 'function'
  );
}

// Extract generator functions with proper typing
const prettierModule = prettierConfigModule as any;
const generatePrettierConfig: ConfigGenerator = prettierModule.generate || prettierModule.default?.generate || (() => {
  throw new Error('Prettier config module does not have a generate function');
});

const generateBiomeConfig: ConfigGenerator<{
  indentation?: { style: 'space' | 'tab'; width: number };
  lineWidth?: number;
  quotes?: { style: 'single' | 'double'; jsx: 'single' | 'double' };
  semicolons?: 'always' | 'asNeeded' | boolean;
  trailingComma?: 'all' | 'es5' | 'none';
  arrowParens?: 'always' | 'asNeeded';
}> = biomeConfigModule.generate;

/**
 * Generate configuration files for available formatters
 */
export async function generateConfigs(
  formatters: FormatterType[],
  preset: PresetConfig,
  yamlPreset?: YamlPreset,
): Promise<Result<GeneratedConfig[], Error>> {
  try {
    const configs: GeneratedConfig[] = [];

    for (const formatter of formatters) {
      const configResult = await generateFormatterConfig(formatter, preset, yamlPreset);
      if (configResult.success) {
        configs.push(configResult.data);
      } else {
        return failure(configResult.error);
      }
    }

    return success(configs);
  } catch (error) {
    return failure(
      makeError('INTERNAL_ERROR', 'Failed to generate configuration files', { cause: error }),
    );
  }
}

/**
 * Generate configuration for a specific formatter
 */
export async function generateFormatterConfig(
  formatter: FormatterType,
  preset: PresetConfig,
  yamlPreset?: YamlPreset,
): Promise<Result<GeneratedConfig, Error>> {
  try {
    switch (formatter) {
      case 'prettier':
        return generatePrettierConfigFile(preset, yamlPreset);
      case 'biome':
        return generateBiomeConfigFile(preset, yamlPreset);
      case 'remark':
        return generateRemarkConfigFile(preset, yamlPreset);
      default:
        return failure(makeError('VALIDATION_ERROR', `Unknown formatter: ${formatter}`));
    }
  } catch (error) {
    return failure(
      makeError('INTERNAL_ERROR', `Failed to generate ${formatter} configuration`, {
        cause: error,
      }),
    );
  }
}

/**
 * Generate Prettier configuration file
 */
function generatePrettierConfigFile(preset: PresetConfig, yamlPreset?: YamlPreset): Result<GeneratedConfig, Error> {
  try {
    let config = generatePrettierConfig(preset);
    
    // Apply raw overrides from YAML preset if available
    if (yamlPreset?.raw?.prettier) {
      config = mergeRawConfig(config, yamlPreset.raw.prettier);
    }

    // Generate as YAML for better comment support
    const yamlConfig = {
      ...config,
      // Ensure proper formatting for YAML
      _preset: preset.name,
    };
    
    const header = `# Generated by @outfitter/formatting\n# Tool: prettier\n# Preset: ${preset.name}\n\n`;
    const content = header + stringifyYaml(yamlConfig);

    return success({
      path: '.prettierrc.yaml',
      content,
      formatter: 'prettier',
      generated: true,
    });
  } catch (error) {
    return failure(
      makeError('INTERNAL_ERROR', 'Failed to generate Prettier configuration', { cause: error }),
    );
  }
}

/**
 * Generate Biome configuration file
 */
function generateBiomeConfigFile(preset: PresetConfig, yamlPreset?: YamlPreset): Result<GeneratedConfig, Error> {
  try {
    // Check if generateBiomeConfig is a function
    if (typeof generateBiomeConfig !== 'function') {
      return failure(
        makeError('INTERNAL_ERROR', 'generateBiomeConfig is not a function', {
          type: typeof generateBiomeConfig,
          value: generateBiomeConfig,
        }),
      );
    }

    // Map PresetConfig to BiomeConfigOptions
    const biomeOptions = {
      indentation: preset.indentation
        ? {
            style: preset.indentation.style,
            width: preset.indentation.width,
          }
        : undefined,
      lineWidth: preset.lineWidth,
      quotes: preset.quotes
        ? {
            style: preset.quotes.style,
            jsx: preset.quotes.jsx || preset.quotes.style,
          }
        : undefined,
      semicolons: preset.semicolons,
      trailingComma: preset.trailingComma,
      arrowParens: preset.arrowParens,
    };

    let config = generateBiomeConfig(biomeOptions);
    
    // Apply raw overrides from YAML preset if available
    if (yamlPreset?.raw?.biome) {
      config = mergeRawConfig(config, yamlPreset.raw.biome);
    }

    // Generate as JSONC for comment support
    const header = `// Generated by @outfitter/formatting\n// Tool: biome\n// Preset: ${preset.name}\n// Schema: https://biomejs.dev/schemas/1.9.4/schema.json\n`;
    const content = header + JSON.stringify(config, null, 2) + '\n';

    return success({
      path: 'biome.jsonc',
      content,
      formatter: 'biome',
      generated: true,
    });
  } catch (error) {
    return failure(
      makeError('INTERNAL_ERROR', 'Failed to generate Biome configuration', { cause: error }),
    );
  }
}

/**
 * Generate Remark configuration file
 */
function generateRemarkConfigFile(preset: PresetConfig, yamlPreset?: YamlPreset): Result<GeneratedConfig, Error> {
  try {
    // Map preset to remark preset name
    const remarkPresetName = mapPresetToRemarkPreset(preset.name);
    let config = generateRemarkConfig({ preset: remarkPresetName });
    
    // Apply raw overrides from YAML preset if available
    if (yamlPreset?.raw?.remark) {
      // For remark, we need to handle plugins array specially
      const rawConfig = yamlPreset.raw.remark as { plugins?: unknown[]; settings?: Record<string, unknown> };
      if (rawConfig.plugins) {
        config.plugins = [...(config.plugins || []), ...(rawConfig.plugins || [])];
      }
      if (rawConfig.settings) {
        config.settings = mergeRawConfig(config.settings || {}, rawConfig.settings) as Record<string, unknown>;
      }
    }

    // Generate YAML configuration
    const yamlConfig = {
      plugins: config.plugins,
      settings: config.settings,
    };

    const content = `# Generated by @outfitter/formatting\n# Tool: remark\n# Preset: ${preset.name}\n\n${stringifyYaml(yamlConfig)}`;

    return success({
      path: '.remarkrc.yaml',
      content,
      formatter: 'remark',
      generated: true,
    });
  } catch (error) {
    return failure(
      makeError('INTERNAL_ERROR', 'Failed to generate Remark configuration', { cause: error }),
    );
  }
}

/**
 * Generate package.json scripts for formatters
 */
export function generatePackageJsonScripts(formatters: FormatterType[]): Record<string, string> {
  const scripts: Record<string, string> = {};

  // Generate individual formatter scripts
  for (const formatter of formatters) {
    switch (formatter) {
      case 'prettier':
        scripts['format:prettier'] = 'prettier --write .';
        scripts['format:prettier:check'] = 'prettier --check .';
        break;
      case 'biome':
        scripts['format:biome'] = 'biome format --write .';
        scripts['format:biome:check'] = 'biome format .';
        scripts['lint:biome'] = 'biome lint .';
        scripts['lint:biome:fix'] = 'biome lint --write .';
        break;
      case 'remark':
        scripts['format:markdown'] = 'remark . --output';
        scripts['format:markdown:check'] = 'remark . --frail';
        break;
    }
  }

  // Generate combined scripts if multiple formatters
  if (formatters.length > 1) {
    const formatCommands = [];
    const checkCommands = [];

    if (formatters.includes('prettier')) {
      formatCommands.push('pnpm format:prettier');
      checkCommands.push('pnpm format:prettier:check');
    }

    if (formatters.includes('biome')) {
      formatCommands.push('pnpm format:biome');
      checkCommands.push('pnpm format:biome:check');
    }

    if (formatters.includes('remark')) {
      formatCommands.push('pnpm format:markdown');
      checkCommands.push('pnpm format:markdown:check');
    }

    if (formatCommands.length > 0) {
      scripts['format'] = formatCommands.join(' && ');
      scripts['format:check'] = checkCommands.join(' && ');
    }
  } else if (formatters.length === 1) {
    // Single formatter - create simple aliases
    const formatter = formatters[0];
    switch (formatter) {
      case 'prettier':
        scripts['format'] = 'prettier --write .';
        scripts['format:check'] = 'prettier --check .';
        break;
      case 'biome':
        scripts['format'] = 'biome format --write .';
        scripts['format:check'] = 'biome format .';
        scripts['lint'] = 'biome lint .';
        scripts['lint:fix'] = 'biome lint --write .';
        break;
      case 'remark':
        scripts['format'] = 'remark . --output';
        scripts['format:check'] = 'remark . --frail';
        break;
    }
  }

  return scripts;
}

/**
 * Map formatting preset to remark preset
 */
function mapPresetToRemarkPreset(preset: PresetConfig['name']): 'standard' | 'strict' | 'relaxed' {
  return preset; // Direct mapping for now
}


// Import devcontainer generators
import { generateDevContainerConfig, formatDevContainerConfig } from '../generators/devcontainer.js';

/**
 * Generate devcontainer configuration
 */
export function generateDevContainer(
  detectionResult: FormatterDetectionResult,
  options: SetupOptions,
): { filename: string; content: string } | undefined {
  if (!options.devcontainer) {
    return undefined;
  }

  // Convert detection result to simple formatter detection object
  const formatters: FormatterDetection = {
    prettier: detectionResult.available.includes('prettier'),
    biome: detectionResult.available.includes('biome'),
    remark: detectionResult.available.includes('remark'),
  };

  const config = generateDevContainerConfig(formatters, options.preset);
  const content = formatDevContainerConfig(config);

  return {
    filename: '.devcontainer/devcontainer.json',
    content,
  };
}
