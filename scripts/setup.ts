#!/usr/bin/env bun

/**
 * Outfitter Monorepo Setup Orchestrator
 * Advanced setup logic with environment-specific optimizations
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs';
import { join } from 'node:path';
import { parseArgs } from 'node:util';
import { $ } from 'bun';

// Environment types
type Environment = 'local' | 'ci' | 'github-actions' | 'devin' | 'factory' | 'codex' | 'docker';

// Valid environments for validation
const VALID_ENVIRONMENTS: readonly Environment[] = [
  'local', 'ci', 'github-actions', 'devin', 'factory', 'codex', 'docker'
] as const;

// Parse command line arguments
const { values } = parseArgs({
  args: process.argv.slice(2),
  options: {
    environment: { type: 'string', default: 'local' },
    'skip-build': { type: 'boolean', default: false },
    'skip-hooks': { type: 'boolean', default: false },
    verbose: { type: 'boolean', default: false },
  },
});

// Validate and set environment
const environment = (() => {
  const env = (values.environment || 'local') as Environment;
  if (!VALID_ENVIRONMENTS.includes(env)) {
    console.error(`‚úó Invalid environment: ${env}`);
    console.error(`  Must be one of: ${VALID_ENVIRONMENTS.join(', ')}`);
    process.exit(1);
  }
  return env;
})();

const skipBuild = values['skip-build'] || false;
const skipHooks = values['skip-hooks'] || false;
const verbose = values.verbose || false;

// Console helpers
const log = (message: string) => console.log(`‚úì ${message}`);
const warn = (message: string) => console.warn(`‚ö† ${message}`);
const error = (message: string) => console.error(`‚úó ${message}`);
const debug = (message: string) => verbose && console.log(`  ${message}`);

// Performance tracking
const startTime = performance.now();

/**
 * Generate environment-specific bunfig.toml
 */
function generateBunfigForEnvironment(env: Environment): string {
  const baseConfig = `
# Auto-generated bunfig.toml for ${env} environment
# Generated by setup.ts

[install]
linkWorkspacePackages = true
exact = false
cache = true
registry = "https://registry.npmjs.org"
`;

  const envConfigs: Record<Environment, string> = {
    local: `
# Local development settings
optional = false
dev = true
peer = true
production = false
frozenLockfile = false
concurrentScripts = 8

[install.cache]
disable = false

[install.lockfile]
save = true
print = "yarn"
`,

    ci: `
# CI environment settings
optional = false
dev = true
peer = true
production = false
frozenLockfile = true
concurrentScripts = 8

[install.cache]
disable = false

[install.lockfile]
save = true
print = "yarn"
`,

    'github-actions': `
# GitHub Actions settings
optional = false
dev = true
peer = true
production = false
frozenLockfile = true
concurrentScripts = 8

[install.cache]
disable = false

[install.lockfile]
save = true
print = "yarn"
`,

    docker: `
# Docker environment settings
optional = false
dev = false
peer = true
production = true
frozenLockfile = true
concurrentScripts = 8

[install.cache]
dir = "/tmp/bun-cache"
disable = false

[install.lockfile]
save = false
`,

    devin: `
# Devin.ai agent settings
optional = false
dev = true
peer = true
production = false
frozenLockfile = false
concurrentScripts = 8

[install.cache]
dir = "/workspace/.cache/bun"
disable = false

[install.lockfile]
save = true
print = "yarn"
`,

    factory: `
# Factory.ai agent settings
optional = false
dev = false
peer = true
production = true
frozenLockfile = true
concurrentScripts = 8

[install.cache]
dir = "/tmp/bun-cache"
disable = false

[install.lockfile]
save = false
`,

    codex: `
# OpenAI Codex agent settings
optional = false
dev = true
peer = false
production = false
frozenLockfile = false
concurrentScripts = 16

# lifecycle scripts should be handled at install time:
# e.g., bun install --ignore-scripts

[install.cache]
dir = "/tmp/fast-cache"
disable = false
disableManifest = true

[install.lockfile]
save = true
print = "yarn"
`,

  };

  const overlay = envConfigs[env] ?? "";
  return baseConfig + overlay + `
[install.scopes]
"@outfitter" = { registry = "https://registry.npmjs.org" }
"@biomejs" = { registry = "https://registry.npmjs.org" }
"@changesets" = { registry = "https://registry.npmjs.org" }

# Note: Test and run configurations are not supported in bunfig.toml
# Use CLI flags or environment variables instead
`;
}

/**
 * Backup existing bunfig.toml if it exists
 */
function backupExistingConfig(): void {
  const configPath = 'bunfig.toml';
  if (existsSync(configPath)) {
    const backupPath = `bunfig.toml.backup.${Date.now()}`;
    const content = readFileSync(configPath, 'utf-8');
    writeFileSync(backupPath, content);
    debug(`Backed up existing config to ${backupPath}`);
  }
}

/**
 * Write environment-specific bunfig.toml
 */
function writeEnvironmentConfig(env: Environment): void {
  const config = generateBunfigForEnvironment(env);
  writeFileSync('bunfig.toml', config);
  log(`Generated bunfig.toml for ${env} environment`);
}

/**
 * Run command with retry logic
 */
async function runWithRetry(command: string, maxRetries = 3): Promise<void> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      debug(`Running: ${command} (attempt ${attempt})`);
      // Use a login shell so complex commands/flags are handled consistently
      await $`bash -lc ${command}`.quiet(!verbose);
      return;
    } catch (err) {
      const error = err as Error & { exitCode?: number; signal?: string };
      if (attempt === maxRetries) {
        throw new Error(
          `Command failed after ${maxRetries} attempts: ${command}\n` +
          `Last error: ${error.message}\n` +
          `Exit code: ${error.exitCode ?? 'unknown'}`
        );
      }
      warn(`Command failed (exit ${error.exitCode ?? 'unknown'}), retrying... (${attempt}/${maxRetries})`);
      // Exponential backoff with async sleep
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

/**
 * Install dependencies with environment-specific optimizations
 */
async function installDependencies(env: Environment): Promise<void> {
  log('Installing dependencies...');
  
  let installCommand = 'bun install';
  
  // Add environment-specific flags
  switch (env) {
    case 'ci':
    case 'github-actions':
    case 'docker':
      installCommand += ' --frozen-lockfile';
      break;
    case 'factory':
      installCommand += ' --production --frozen-lockfile --no-verify';
      break;
    case 'codex':
      installCommand += ' --ignore-scripts';
      break;
  }
  
  await runWithRetry(installCommand);
  log('Dependencies installed successfully');
}

/**
 * Build packages if not skipped
 */
async function buildPackages(): Promise<void> {
  if (skipBuild) {
    debug('Skipping build (--skip-build flag)');
    return;
  }
  
  log('Building packages...');
  try {
    await $`bun run build`.quiet(!verbose).timeout('300s');
    log('Build completed successfully');
  } catch (err) {
    const error = err as Error & { killed?: boolean; signal?: string };
    if (error.killed) {
      warn('Build timed out after 5 minutes');
    } else {
      warn('Build failed - some packages may not be fully functional');
    }
    if (environment === 'ci' || environment === 'github-actions') {
      throw err; // Fail in CI environments
    }
  }
}

/**
 * Setup git hooks if not skipped
 */
async function setupGitHooks(): Promise<void> {
  if (skipHooks) {
    debug('Skipping git hooks (--skip-hooks flag)');
    return;
  }
  
  if (!existsSync('.git')) {
    debug('Not a git repository, skipping hooks');
    return;
  }
  
  try {
    await $`bunx lefthook install`.quiet();
    log('Git hooks configured');
  } catch (err) {
    warn('Failed to setup git hooks');
  }
}

/**
 * Validate setup completion
 */
function validateSetup(env: Environment): boolean {
  const checks = [
    { path: 'node_modules', name: 'Dependencies' },
    { path: 'bun.lock', name: 'Lockfile' },
  ];
  
  // Only check for bunfig.toml in non-local environments
  if (env !== 'local') {
    checks.push({ path: 'bunfig.toml', name: 'Configuration' });
  }
  
  let allValid = true;
  
  for (const check of checks) {
    if (existsSync(check.path)) {
      debug(`${check.name} present`);
    } else {
      warn(`${check.name} missing`);
      allValid = false;
    }
  }
  
  return allValid;
}

/**
 * Main setup orchestration
 */
async function main() {
  console.log('üöÄ Outfitter Monorepo Setup Orchestrator');
  console.log('=========================================');
  log(`Environment: ${environment}`);
  
  // Enforce Node.js minimum version for toolchain compatibility
  const MIN_NODE = '20.0.0';
  const cur = process.versions.node ?? '0.0.0';
  const parse = (v: string) => v.split('.').map((n) => parseInt(n, 10));
  const [a1, b1, c1] = parse(cur);
  const [a2, b2, c2] = parse(MIN_NODE);
  const tooOld =
    a1 < a2 || (a1 === a2 && (b1 < b2 || (b1 === b2 && c1 < c2)));
  if (tooOld) {
    error(`Node.js >= ${MIN_NODE} required (detected ${cur}). Please upgrade Node before continuing.`);
    process.exit(1);
  }
  
  try {
    // Phase 1: Configuration
    if (environment !== 'local') {
      backupExistingConfig();
      writeEnvironmentConfig(environment);
    }
    
    // Phase 2: Dependencies
    await installDependencies(environment);
    
    // Phase 3: Build
    await buildPackages();
    
    // Phase 4: Git hooks (local only)
    if (environment === 'local') {
      await setupGitHooks();
    }
    
    // Phase 5: Validation
    const isValid = validateSetup(environment);
    
    // Performance summary
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
    console.log('');
    if (isValid) {
      console.log(`‚úÖ Setup completed successfully in ${elapsed}s`);
    } else {
      console.log(`‚ö†Ô∏è  Setup completed with warnings in ${elapsed}s`);
    }
    
    // Environment-specific notes
    switch (environment) {
      case 'local':
        console.log('üìù Run "bun run dev" to start development');
        break;
      case 'ci':
      case 'github-actions':
        console.log('üìù Ready for CI pipeline execution');
        break;
      case 'devin':
      case 'factory':
      case 'codex':
        console.log('üìù Agent environment configured and ready');
        break;
    }
    
    process.exit(isValid ? 0 : 1);
  } catch (err) {
    error(`Setup failed: ${err}`);
    process.exit(1);
  }
}

// Run setup
main();